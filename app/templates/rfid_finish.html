{% extends "base.html" %}
{% block title %}{{ _('Finish Check') }}{% endblock %}

{% block content %}
<div class="row g-3">
  <div class="col-lg-6">
    <div class="card shadow-sm h-100">
      <div class="card-body">
        <h5 class="card-title mb-3">{{ _('Finish-line Check') }}</h5>
        <p class="text-body-secondary small mb-3">
          {{ _('Tap the tag to read its UID and stored digests. We will verify which checkpoints match the truncated HMACs.') }}
        </p>

        <form id="finishForm" class="row g-3">
          <div class="col-12">
            <label class="form-label">{{ _('Limit to checkpoints (optional)') }}</label>
            <select id="checkpointFilter" class="form-select" multiple size="6">
              {% for cp in checkpoints %}
                <option value="{{ cp.id }}">{{ cp.name }}</option>
              {% endfor %}
            </select>
            <div class="form-text">{{ _('Leave empty to check against all checkpoints.') }}</div>
          </div>

          <div class="col-12 d-flex gap-2">
            <button class="btn btn-primary" type="submit" id="scanBtn" {% if not checkpoints %}disabled{% endif %}>
              {{ _('Tap tag: read + verify') }}
            </button>
          </div>

          <div class="col-12">
            <label class="form-label">{{ _('Last UID') }}</label>
            <input class="form-control" id="uidField" readonly>
          </div>
          <div class="col-12">
            <label class="form-label">{{ _('Digests read') }}</label>
            <textarea class="form-control" id="digestsField" rows="4" readonly></textarea>
            <div class="form-text">{{ _('From text records on the tag (one per line).') }}</div>
          </div>
        </form>
      </div>
    </div>
  </div>

  <div class="col-lg-6">
    <div class="card shadow-sm h-100">
      <div class="card-body">
        <h6 class="card-title mb-3">{{ _('Results') }}</h6>
        <div id="resultBox" class="alert alert-secondary">{{ _('Awaiting scan...') }}</div>
        <div class="border rounded-3 p-3 mb-3">
          <div class="d-flex align-items-center gap-2">
            <strong>{{ _('Web NFC') }}</strong>
            <span class="badge text-bg-secondary" id="webNfcStatus">{{ _('Checking…') }}</span>
          </div>
          <p class="small text-body-secondary mb-0">
            {{ _('Needs Android Chrome 89+. We read text records, split by lines, and compare to all checkpoints (or your selection).') }}
          </p>
        </div>
        <div id="resultsList" class="small"></div>
      </div>
    </div>
  </div>
</div>

<script>
  const form = document.getElementById("finishForm");
  const scanBtn = document.getElementById("scanBtn");
  const checkpointFilter = document.getElementById("checkpointFilter");
  const uidField = document.getElementById("uidField");
  const digestsField = document.getElementById("digestsField");
  const resultBox = document.getElementById("resultBox");
  const resultsList = document.getElementById("resultsList");
  const webNfcStatus = document.getElementById("webNfcStatus");
  const hasWebNfc = typeof NDEFReader !== "undefined";

  function setBusy(busy) {
    scanBtn.disabled = busy;
  }

  function showMessage(text, variant) {
    resultBox.className = `alert alert-${variant}`;
    resultBox.textContent = text;
  }

  const I18N = {
    mismatch: "{{ _('Mismatch: tag digests include checkpoints the team has not checked into.') }}",
    verified: "{{ _('Verification complete.') }}",
    team: "{{ _('Team') }}",
    checked: "{{ _('checked') }}",
    missing: "{{ _('missing check-in') }}",
    noMatch: "{{ _('No match') }}",
    collision: "{{ _('collision') }}",
    unknown: "{{ _('Unknown') }}",
    noDigests: "{{ _('No digests found.') }}",
    nfcNotAvailable: "{{ _('Web NFC not available in this browser.') }}",
    tapToRead: "{{ _('Tap a tag to read…') }}",
    verificationFailed: "{{ _('Verification failed.') }}",
    nfcReadError: "{{ _('Web NFC read error.') }}",
    nfcNotAvailableShort: "{{ _('Web NFC not available.') }}",
    supported: "{{ _('Supported') }}",
    notAvailable: "{{ _('Not available') }}",
  };

  function extractDigests(records) {
    const decoder = new TextDecoder();
    const texts = [];
    (records || []).forEach((rec) => {
      if (rec.recordType === "text") {
        if (typeof rec.data === "string") {
          texts.push(rec.data);
        } else if (rec.data instanceof DataView) {
          texts.push(decoder.decode(rec.data));
        }
      }
    });
    return texts.join("\n").split(/\r?\n/).map(t => t.trim()).filter(Boolean);
  }

  function renderResults(data) {
    const hasMismatch = !!data.has_mismatch;
    const team = data.team;
    if (hasMismatch) {
      showMessage(I18N.mismatch, "warning");
    } else {
      showMessage(I18N.verified, "success");
    }
    const header = team ? `<div class="mb-2">${I18N.team}: <strong>${team.name}</strong></div>` : "";

    const html = [];
    const results = data.results || [];
    if (!results.length) {
      html.push(`<p class='text-muted mb-0'>${I18N.noDigests}</p>`);
    } else {
      results.forEach(r => {
        const matches = r.matches || [];
        const matchText = matches.length
          ? matches.map(m => {
              const idLabel = m.checkpoint_id || m.device_id || "";
              const base = `${idLabel}${m.checkpoint ? " (" + m.checkpoint + ")" : ""}`;
              if (m.checked_in === true) {
                return `${base} <span class="badge text-bg-success">${I18N.checked}</span>`;
              } else if (m.checked_in === false && m.checkpoint_id) {
                return `${base} <span class="badge text-bg-warning">${I18N.missing}</span>`;
              }
              return base;
            }).join(", ")
          : I18N.noMatch;
        const badge = r.collision ? `<span class="badge text-bg-warning ms-2">${I18N.collision}</span>` : "";
        html.push(
          `<div class="mb-2"><code>${r.digest}</code> → ${matchText}${badge}</div>`
        );
      });
      if ((data.unknown || []).length) {
        html.push(`<div class="text-warning mt-2">${I18N.unknown}: ${data.unknown.join(", ")}</div>`);
      }
    }
    resultsList.innerHTML = header + html.join("");
  }

  async function handleScan(event) {
    event.preventDefault();
    if (!hasWebNfc) {
      showMessage(I18N.nfcNotAvailable, "danger");
      return;
    }
    setBusy(true);
    try {
      const reader = new NDEFReader();
      await reader.scan();
      showMessage(I18N.tapToRead, "info");

      const onRead = async (evt) => {
        reader.removeEventListener("reading", onRead);
        try {
          const uid = (evt.serialNumber || "").toUpperCase();
          const digests = extractDigests(evt.message?.records || []);
          uidField.value = uid;
          digestsField.value = digests.join("\n");

          const selectedCheckpoints = Array.from(checkpointFilter.selectedOptions || []).map(o => o.value).filter(Boolean);
          const resp = await fetch("/api/rfid/verify", {
            method: "POST",
            credentials: "same-origin",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              uid: uid,
              digests: digests,
              checkpoint_ids: selectedCheckpoints,
            }),
          });
          const data = await resp.json();
          if (!resp.ok) {
            throw new Error(data.detail || data.error || `HTTP ${resp.status}`);
          }
          renderResults(data);
        } catch (err) {
          showMessage(err.message || I18N.verificationFailed, "danger");
          resultsList.innerHTML = "";
        } finally {
          setBusy(false);
        }
      };

      const onError = () => {
        reader.removeEventListener("reading", onRead);
        showMessage(I18N.nfcReadError, "danger");
        setBusy(false);
      };

      reader.addEventListener("reading", onRead);
      reader.addEventListener("readingerror", onError, { once: true });
    } catch (err) {
      showMessage(err.message || I18N.nfcNotAvailableShort, "danger");
      setBusy(false);
    }
  }

  form?.addEventListener("submit", handleScan);

  if (hasWebNfc) {
    webNfcStatus.textContent = I18N.supported;
    webNfcStatus.className = "badge text-bg-success";
  } else {
    webNfcStatus.textContent = I18N.notAvailable;
    webNfcStatus.className = "badge text-bg-secondary";
  }
</script>
{% endblock %}
