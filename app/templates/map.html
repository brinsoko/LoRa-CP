{% extends "base.html" %}
{% block title %}Checkpoint Map{% endblock %}
{% block content %}

<div class="d-flex align-items-end gap-3 mb-3">
  <div class="flex-grow-1">
    <label class="form-label">Team</label>
    <select id="teamSelect" class="form-select">
      <option value="">— Select a team —</option>
      {% for t in teams %}
        <option value="{{ t.id }}">{{ t.name }}{% if t.number %} ({{ t.number }}){% endif %}</option>
      {% endfor %}
    </select>
  </div>
  <div class="text-muted small">
    Legend:&nbsp;
    <span class="badge bg-success">found</span>
    <span class="badge bg-primary">next</span>
    <span class="badge bg-secondary">not found</span>
  </div>
</div>

<div id="map" style="height: 70vh; width: 100%; border-radius: 12px; overflow: hidden;"></div>

<!-- Leaflet (no API key needed) -->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
  crossorigin=""
/>
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>
<script>
  // Colors: Bootstrap palette
  const COLOR_FOUND     = "#198754"; // success
  const COLOR_NEXT      = "#0d6efd"; // primary
  const COLOR_NOT_FOUND = "#6c757d"; // secondary

  let map, markers = [];
  let checkpoints = [];

  async function getJSON(url) {
    const r = await fetch(url, { credentials: "same-origin" });
    if (!r.ok) throw new Error(await r.text());
    return await r.json();
  }

  function clearMarkers() {
    markers.forEach(m => map.removeLayer(m));
    markers = [];
  }

  function toLatLng(easting, northing) {
    if (easting == null || northing == null) {
      return null;
    }
    const x = Number(easting);
    const y = Number(northing);
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      return null;
    }

    const a = 6378137.0;
    const f = 1 / 298.257222101;
    const e2 = 2 * f - f * f;
    const e4 = e2 * e2;
    const e6 = e4 * e2;
    const ep2 = e2 / (1 - e2);

    const k0 = 0.9999;
    const lon0 = 15 * Math.PI / 180;
    const falseE = 500000.0;
    const falseN = -5000000.0;

    const E = (x - falseE) / k0;
    const N = (y - falseN) / k0;

    const M = N;
    const mu = M / (a * (1 - e2/4 - 3*e4/64 - 5*e6/256));
    const e1 = (1 - Math.sqrt(1 - e2)) / (1 + Math.sqrt(1 - e2));

    const J1 = (3*e1/2 - 27*Math.pow(e1,3)/32);
    const J2 = (21*Math.pow(e1,2)/16 - 55*Math.pow(e1,4)/32);
    const J3 = (151*Math.pow(e1,3)/96);
    const J4 = (1097*Math.pow(e1,4)/512);

    const phi1 = mu + J1 * Math.sin(2*mu) + J2 * Math.sin(4*mu) + J3 * Math.sin(6*mu) + J4 * Math.sin(8*mu);

    const sinPhi1 = Math.sin(phi1);
    const cosPhi1 = Math.cos(phi1);
    const tanPhi1 = Math.tan(phi1);

    const C1 = ep2 * cosPhi1 * cosPhi1;
    const T1 = tanPhi1 * tanPhi1;
    const N1 = a / Math.sqrt(1 - e2 * sinPhi1 * sinPhi1);
    const R1 = a * (1 - e2) / Math.pow(1 - e2 * sinPhi1 * sinPhi1, 1.5);
    const D = E / N1;

    const lat = phi1 - (N1 * tanPhi1 / R1) * (Math.pow(D,2) / 2 - (5 + 3*T1 + 10*C1 - 4*C1*C1 - 9*ep2) * Math.pow(D,4) / 24 + (61 + 90*T1 + 298*C1 + 45*T1*T1 - 252*ep2 - 3*C1*C1) * Math.pow(D,6) / 720);
    const lon = lon0 + (D - (1 + 2*T1 + C1) * Math.pow(D,3) / 6 + (5 - 2*C1 + 28*T1 - 3*C1*C1 + 8*ep2 + 24*T1*T1) * Math.pow(D,5) / 120) / cosPhi1;

    const latDeg = lat * 180 / Math.PI;
    const lonDeg = lon * 180 / Math.PI;

    if (!Number.isFinite(latDeg) || !Number.isFinite(lonDeg)) {
      return null;
    }

    return [latDeg, lonDeg];
  }

  function colorForStatus(status) {
    switch ((status || "").toLowerCase()) {
      case "found": return COLOR_FOUND;
      case "next": return COLOR_NEXT;
      default: return COLOR_NOT_FOUND;
    }
  }

  function drawMarkers(itemsWithStatus) {
    clearMarkers();
    const latlngs = [];

    itemsWithStatus.forEach(cp => {
      const latlng = toLatLng(cp.easting, cp.northing);
      if (!latlng) {
        console.warn("Skipping checkpoint without valid coords", cp);
        return;
      }
      latlngs.push(latlng);

      const status = (cp.status || "not_found");
      const color  = colorForStatus(status);

      const circle = L.circleMarker(latlng, {
        radius: 6,
        color,
        fillColor: color,
        fillOpacity: 1,
        weight: 1,
      }).bindPopup(
        `<strong>${cp.name}</strong><br>` +
        `E: ${cp.easting ?? "—"}, N: ${cp.northing ?? "—"}<br>` +
        `Status: ${status.replace("_"," ")}`
      );

      circle.addTo(map);
      markers.push(circle);
    });

    if (latlngs.length > 0) {
      const bounds = L.latLngBounds(latlngs);
      map.fitBounds(bounds.pad(0.2));
    } else {
      map.setView([45.95, 14.36], 12);
    }
  }

  async function fetchStatusItemsRest(teamId) {
    const url = teamId
      ? `/api/map/checkpoints?team_id=${encodeURIComponent(teamId)}`
      : `/api/map/checkpoints`;
    const data = await getJSON(url);
    // If backend doesn’t add `status` yet, normalize to "not_found"
    return (data || []).map(d => ({ ...d, status: d.status || "not_found" }));
  }

  async function fetchStatusItems(teamId) {
    return await fetchStatusItemsRest(teamId);
  }

  async function refresh(teamId) {
    const items = await fetchStatusItems(teamId);
    drawMarkers(items);
  }

  async function init() {
    // Base map
    map = L.map("map");
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap contributors"
    }).addTo(map);

    // Initial load: all checkpoints as not_found
    const items = await fetchStatusItems(""); // no team
    drawMarkers(items);

    // Team selection handler
    document.getElementById("teamSelect").addEventListener("change", (e) => {
      const teamId = e.target.value || "";
      refresh(teamId);
    });
  }

  document.addEventListener("DOMContentLoaded", init);
</script>

{% endblock %}
