{% extends "base.html" %}
{% block title %}Checkpoint Map{% endblock %}
{% block content %}

<div class="d-flex align-items-end gap-3 mb-3">
  <div class="flex-grow-1">
    <label class="form-label">Team</label>
    <select id="teamSelect" class="form-select">
      <option value="">— Select a team —</option>
      {% for t in teams %}
        <option value="{{ t.id }}">{{ t.name }}{% if t.number %} ({{ t.number }}){% endif %}</option>
      {% endfor %}
    </select>
  </div>
  <div class="text-muted small">
    Legend:&nbsp;
    <span class="badge bg-success">found</span>
    <span class="badge bg-secondary">not found</span>
  </div>
</div>

<div id="map" style="height: 70vh; width: 100%; border-radius: 12px; overflow: hidden;"></div>

<!-- Leaflet (no API key needed) -->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
  crossorigin=""
/>
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<script>
  const COLOR_FOUND = "#198754";      // bootstrap success
  const COLOR_NOT_FOUND = "#6c757d";  // bootstrap secondary

  let map, markers = [];
  let checkpoints = [];

  async function getJSON(url) {
    const r = await fetch(url, { credentials: "same-origin" });
    if (!r.ok) throw new Error(await r.text());
    return await r.json();
  }

  function clearMarkers() {
    markers.forEach(m => map.removeLayer(m));
    markers = [];
  }

  // ⚠️ Stub conversion: replace with your real projection when ready.
  function toLatLng(easting, northing) {
    const originLat = 45.95;
    const originLng = 14.36;
    const scale = 0.00001;
    const lat = originLat + ((northing || 0) * scale);
    const lng = originLng + ((easting || 0) * scale);
    return [lat, lng];
  }

  function drawMarkers(foundSet) {
    clearMarkers();
    const latlngs = [];

    checkpoints.forEach(cp => {
      const found = foundSet.has(cp.id);
      const latlng = toLatLng(cp.easting, cp.northing);
      latlngs.push(latlng);

      const circle = L.circleMarker(latlng, {
        radius: 6,
        color: found ? COLOR_FOUND : COLOR_NOT_FOUND,
        fillColor: found ? COLOR_FOUND : COLOR_NOT_FOUND,
        fillOpacity: 1,
        weight: 1,
      }).bindPopup(
        `<strong>${cp.name}</strong><br>E: ${cp.easting ?? "—"}, N: ${cp.northing ?? "—"}<br>Status: ${found ? "found" : "not found"}`
      );

      circle.addTo(map);
      markers.push(circle);
    });

    // Fit bounds if we have points; otherwise set a sensible center.
    if (latlngs.length > 0) {
      const bounds = L.latLngBounds(latlngs);
      map.fitBounds(bounds.pad(0.2));
    } else {
      map.setView([45.95, 14.36], 12);
    }
  }

  async function refresh(teamId) {
    if (!teamId) {
      drawMarkers(new Set());
      return;
    }
    const data = await getJSON(`{{ url_for('maps.api_team_found') }}?team_id=${teamId}`);
    const foundSet = new Set(data.found || []);
    drawMarkers(foundSet);
  }

  async function init() {
    // Base map
    map = L.map("map");
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap contributors"
    }).addTo(map);

    // Load checkpoints and draw initial markers (all grey)
    checkpoints = await getJSON(`{{ url_for('maps.api_checkpoints') }}`);
    drawMarkers(new Set());

    // Team selection handler
    document.getElementById("teamSelect").addEventListener("change", (e) => {
      const teamId = e.target.value || "";
      refresh(teamId);
    });
  }

  document.addEventListener("DOMContentLoaded", init);
</script>

{% endblock %}