{% extends "base.html" %}
{% block title %}{{ _('Judge RFID Console') }}{% endblock %}

{% block content %}
<div class="row g-3">
  <div class="col-lg-6">
    <div class="card shadow-sm h-100">
      <div class="card-body">
        <h5 class="card-title mb-3">{{ _('Web NFC: Read → Ingest → Append') }}</h5>
        <p class="text-body-secondary small">
          {{ _('Tap a tag with your phone to read its UID, call ingest for the selected checkpoint, then append the signed payload back onto the tag.') }}
        </p>

        <form id="judgeForm" class="row g-3">
          <div class="col-12">
            <label class="form-label">{{ _('Checkpoint') }}</label>
            <select class="form-select" id="checkpointSelect" required {% if not checkpoints %}disabled{% endif %}>
              {% for cp in checkpoints %}
                <option value="{{ cp.id }}" {% if cp.id == default_checkpoint_id %}selected{% endif %}>
                  {{ cp.name }}
                </option>
              {% endfor %}
            </select>
            <div class="form-text">{{ _('Uses the checkpoint ID sent to /api/ingest.') }}</div>
            {% if not checkpoints %}
              <div class="alert alert-warning mt-2 mb-0 small">{{ _('No checkpoints assigned yet.') }}</div>
            {% endif %}
          </div>

          <div class="col-12">
            <label class="form-label">{{ _('Last UID read') }}</label>
            <input type="text" class="form-control" id="cardUid" readonly>
            <div class="form-text">{{ _('Filled when you tap a tag with Web NFC.') }}</div>
          </div>

          <div class="col-12 d-flex gap-2">
            <button class="btn btn-primary" type="submit" id="submitBtn" {% if not checkpoints %}disabled{% endif %}>
              {{ _('Tap tag: read → ingest → append write') }}
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <div class="col-lg-6">
    <div class="card shadow-sm h-100">
      <div class="card-body">
        <h6 class="card-title mb-3">{{ _('Result') }}</h6>
        <div id="resultBox" class="alert alert-secondary">{{ _('Awaiting input…') }}</div>

        <div class="mb-3">
          <label class="form-label">{{ _('Write-back payload') }}</label>
          <div class="input-group">
            <input type="text" class="form-control" id="writePayload" readonly>
            <button class="btn btn-outline-secondary" type="button" id="copyBtn">{{ _('Copy') }}</button>
          </div>
          <div class="form-text">
            {{ _('Appended to the tag as a text record. We only store the truncated HMAC (checkpoint ID + card UID) to save space.') }}
          </div>
        </div>

        <div class="border rounded-3 p-3">
          <div class="d-flex align-items-center gap-2 mb-2">
            <strong>{{ _('Web NFC') }}</strong>
            <span class="badge text-bg-secondary" id="webNfcStatus">{{ _('Checking…') }}</span>
          </div>
          <p class="small text-body-secondary mb-0">
            {{ _('Supported on Android Chrome 89+. We read existing text records, call ingest, then write them back with the new payload appended. Keep the tag in place until you see success.') }}
          </p>
        </div>

        <pre class="bg-body-tertiary rounded p-2 small" id="rawJson" style="min-height: 160px;">{}</pre>
      </div>
    </div>
  </div>
</div>

<script>
  const form = document.getElementById("judgeForm");
  const resultBox = document.getElementById("resultBox");
  const cardUid = document.getElementById("cardUid");
  const checkpointSelect = document.getElementById("checkpointSelect");
  const submitBtn = document.getElementById("submitBtn");
  const copyBtn = document.getElementById("copyBtn");
  const writePayload = document.getElementById("writePayload");
  const rawJson = document.getElementById("rawJson");
  const webNfcStatus = document.getElementById("webNfcStatus");
  const hasWebNfc = typeof NDEFReader !== "undefined";

  const I18N = {
    team: "{{ _('Team') }}",
    checkpoint: "{{ _('Checkpoint') }}",
    checkinCreated: "{{ _('Check-in created') }}",
    cardNotMapped: "{{ _('Card not mapped to a team') }}",
    ingestCompleted: "{{ _('Ingest completed.') }}",
    pickCheckpoint: "{{ _('Pick a checkpoint first.') }}",
    noWebNfc: "{{ _('Web NFC not available in this browser.') }}",
    tapToRead: "{{ _('Tap a tag to read…') }}",
    noWriteback: "{{ _('Ingest did not return a write-back payload.') }}",
    readIngestAppend: "{{ _('Read, ingested, and appended payload to tag.') }}",
    alreadyPresent: "{{ _('HMAC already on tag; skipped writing.') }}",
    webNfcFailed: "{{ _('Web NFC flow failed.') }}",
    webNfcError: "{{ _('Web NFC read error.') }}",
    webNfcNA: "{{ _('Web NFC not available.') }}",
    copied: "{{ _('Write-back payload copied.') }}",
    copyFailed: "{{ _('Could not copy payload.') }}",
    supported: "{{ _('Supported') }}",
    notAvailable: "{{ _('Not available') }}",
  };

  function setBusy(busy) {
    submitBtn.disabled = busy;
  }

  function showMessage(text, variant) {
    resultBox.className = `alert alert-${variant}`;
    resultBox.textContent = text;
  }

  function renderResult(data) {
    const parts = [];
    if (data.team) parts.push(`${I18N.team}: ${data.team}`);
    if (data.checkpoint) parts.push(`${I18N.checkpoint}: ${data.checkpoint}`);
    if (data.checkin_created) parts.push(I18N.checkinCreated);
    if (data.uid_seen === false) parts.push(I18N.cardNotMapped);
    showMessage(parts.join(" · ") || I18N.ingestCompleted, "success");

    if (data.card_writeback && data.card_writeback.payload) {
      writePayload.value = data.card_writeback.payload;
    } else {
      writePayload.value = "";
    }

    rawJson.textContent = JSON.stringify(data, null, 2);
  }

  function extractText(records) {
    const decoder = new TextDecoder();
    const texts = [];
    (records || []).forEach((rec) => {
      if (rec.recordType === "text") {
        if (typeof rec.data === "string") {
          texts.push(rec.data);
        } else if (rec.data instanceof DataView) {
          texts.push(decoder.decode(rec.data));
        }
      }
    });
    return texts.join("\n").trim();
  }

  function hasExistingPayload(prevText, payload) {
    if (!payload) return false;
    return prevText
      .split(/\r?\n/)
      .map((t) => t.trim())
      .filter(Boolean)
      .includes(payload);
  }

  async function handleSubmit(event) {
    event.preventDefault();
    const checkpointId = parseInt(checkpointSelect.value || "0", 10);
    if (!checkpointId) {
      showMessage(I18N.pickCheckpoint, "warning");
      return;
    }
    if (!hasWebNfc) {
      showMessage(I18N.noWebNfc, "danger");
      return;
    }

    setBusy(true);
    try {
      const reader = new NDEFReader();
      await reader.scan();
      showMessage(I18N.tapToRead, "info");

      const onRead = async (event) => {
        reader.removeEventListener("reading", onRead);
        try {
          const uid = (event.serialNumber || "").toUpperCase();
          cardUid.value = uid;
          const prevText = extractText(event.message?.records || []);

          const competitionId = {{ current_competition.id if current_competition else "null" }};
          const ingestResp = await fetch("/api/ingest", {
            method: "POST",
            credentials: "same-origin",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              competition_id: competitionId,
              checkpoint_id: checkpointId,
              payload: uid,
              ts: Math.floor(Date.now() / 1000),
              source: "judge_web_nfc",
            }),
          });
          const ingestJson = await ingestResp.json();
          if (!ingestResp.ok) {
            throw new Error(ingestJson.detail || ingestJson.error || `HTTP ${ingestResp.status}`);
          }

          const payload = ingestJson?.card_writeback?.payload || "";
          if (!payload) {
            throw new Error(I18N.noWriteback);
          }

          if (hasExistingPayload(prevText, payload)) {
            writePayload.value = payload;
            renderResult(ingestJson);
            showMessage(I18N.alreadyPresent, "info");
            return;
          }

          const combined = prevText ? `${prevText}\n${payload}` : payload;
          const writer = new NDEFReader();
          await writer.write({ records: [{ recordType: "text", data: combined }] });

          writePayload.value = payload;
          renderResult(ingestJson);
          showMessage(I18N.readIngestAppend, "success");
        } catch (err) {
          showMessage(err.message || I18N.webNfcFailed, "danger");
        } finally {
          setBusy(false);
        }
      };

      const onError = () => {
        reader.removeEventListener("reading", onRead);
        showMessage(I18N.webNfcError, "danger");
        setBusy(false);
      };

      reader.addEventListener("reading", onRead);
      reader.addEventListener("readingerror", onError, { once: true });
    } catch (err) {
      showMessage(err.message || I18N.webNfcNA, "danger");
      setBusy(false);
    }
  }

  function handleCopy() {
    if (!writePayload.value) return;
    navigator.clipboard.writeText(writePayload.value).then(
      () => showMessage(I18N.copied, "info"),
      () => showMessage(I18N.copyFailed, "warning")
    );
  }

  copyBtn?.addEventListener("click", handleCopy);
  form?.addEventListener("submit", handleSubmit);

  if (hasWebNfc) {
    webNfcStatus.textContent = I18N.supported;
    webNfcStatus.className = "badge text-bg-success";
  } else {
    webNfcStatus.textContent = I18N.notAvailable;
    webNfcStatus.className = "badge text-bg-secondary";
  }
</script>
{% endblock %}
